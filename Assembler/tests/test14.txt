@testing prediction tables

.text

@testing 1 bit prediction table, 2 wrong predictions per loop(on loop start and loop end)
/*
mov r0, #0		@cycle 5/1
mov r1, #7		@cycle 6/2
loop: add r0, r0, #1	@cycle 7/3
cmp r0, r1		@cycle 8/4
jmi loop		@cycle 10/5 (first predict 0, then predict 1), 13/8, 16/11, 19/14, 22/17, 25/20, 28/23(no jump on last one)
mov r7, #20		@cycle 30/25 (predict 1 incorrectly on loop end)
*/

@testing 2 bit prediction table, only 1 wrong prediction per loop reenter
@exception when at start of program and starting in 00 state

/*
mov r0, #1		@cycle 5/1
loop2: mov r1, #7	@cycle 6/2
loop: add r0, r0, #1	@cycle 7/3
cmp r0, r1		@cycle 8/4
jmi loop		@cycle 10/5 (first 2 times incorrect, predict 0, then predict correct, on loop reenter cycle 35/30 we predict correct)
mov r0, #1		@cycle 28/23 (incorrect prediction on loop exit)
cmp r0, r1
jmi loop2		
*/

@testing correlating predictor
@sometimes 2 branches can take up the same spot in our local prediction table
@because we use a 3 bit addressed LPT, this happens if 2 instructions seperated by 8 addresses are both branches
/*
while (true){
	if(a % 2 == 0){jump}	TNTNTNTNTNT
	a++		
	if(b == 1){jump2}	NNNNNNNNNNN
}
a => r0, b => r1, r5=>stalling command, r3,r4 => counting loops for a and b
*/

/*
loop: 
rem r0, r0, #2
cmp r0, #0
jeq jump1	@2nd instruction

afterjump1:
add r0, r0, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
cmp r1, #1
jeq jump2	@10th instruction, last 3 bits are 010 so it'll have the same LPT spot as the 2nd instruction
add r4, r4, #1
j loop

jump1:
add r3, r3, #1
j afterjump1

jump2:
mov r6, #15
*/

/*
Branch outcomes				Branch predictions when using only 2 bit table: (lpt: 00 -> 01 -> 00 -> 00 -> 00...
jump1		TNTNTNTNTNTNTNTN	jump1	NNNNNN
jump2 		NNNNNNNNNNNNNNNN	jump2	NNNNNN

Becuase they take up the same spot in our LPT, we always misspredict jump1
Branch predictions when using correlating predictor:
LHT: 000 -> 100 -> 010 -> 001 ->	000 -> 		100
LPT: 00 -> 01(00) -> 01(00)(00) -> 01(00)(00)(00) -> 10(00)(00)(00)

jump1: NNNNTNTNTNTN	
jump2: NNNNNNNNNNNN
 The predictions are on average more correct using a correlating predictor when 2 jumps take up the same LPT address.
 After the 4th iteration in our example above, we predict correct jumps everytime for each of our jump instructions.
*/

@testing tournament predictor
@correlating predictor is not always better than a standard 2-bit predictor
@Sometimes, unrelated jumps may affect the correlating predictor and make predictions worse.
@To account for that, we use a tournament predictor,
@ that dinamically chooses whether to to predict using local history(as a correlating predictor) or global history(2-bit predictor)
@ we'll take the same code as baove, but expand it with an extra jump

/*
loop: 
rem r0, r0, #2
cmp r0, #0
jeq jump1	@2nd instruction

afterjump1:
add r0, r0, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
add r5, r5, #1
cmp r1, #1
jeq jump2	@1oth instruction, last 3 bits are 010 so it'll have the same LPT spot as the 2nd instruction
add r4, r4, #1
rem r2, r2, #2
cmp r2, #0
jeq jump3	@another jump, independent to the last 2
afterjump3:
add r2, r2, #1
j loop

jump1:
add r3, r3, #1
j afterjump1

jump2:
mov r7, #15

jump3:
add r6, r6, #1
j afterjump3
*/

/*
Branch outcomes:
jump1		TNTNTNTNTNTNTNTN
jump2 		NNNNNNNNNNNNNNNN
jump3		TNTNTNTNTNTNTNTN

Correlating predictor predictions:
jump1		NNNNNNTNTNTN
jump2 		NNNNNTNTNTNT
jump3		NNNNTNTNTNTN

Because of the extra independent jump, 
our local history table is being modified and we are incorrectly predicting every 2nd jump2 using the correlating predictor.

Tournament predictions:
jump1		NNNNNNTNTNTN
jump2 		NNNNNNNNNNNN
jump3		NNNNTNTNTNTN

After the 5th iteration of jump2, the tournamnet predictor is always correct
*/